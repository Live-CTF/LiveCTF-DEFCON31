#!/usr/bin/env python3
from pwn import *
split = lambda v,sz: [v[i:i+sz] for i in range(0,len(v),sz)]
uu64 = lambda x: u64(x.ljust(8,b'\0')[:8])

HOST = os.environ.get('HOST', 'localhost')
PORT = 31337

io = remote(HOST, PORT)

context.arch = 'amd64'

def rc4(key,data):
    x = [i for i in range(0x100)]
    b = 0
    for i in range(0x100):
        a = x[i]
        b = (key[i&0x1f]+a+b)&0xff
        x[i] = x[b]
        x[b] = a
    c = 0
    data = list(data)
    for i in range(0xff):
        c = (c+1)&0xff
        d = x[c]
        b = (d+b)&0xff
        x[c] = x[b]
        x[b] = d
        data[i]^=x[(x[c]+d)&0xff]
    return data

def solve(exe):
    offset = next(exe.search(b'Correct!\n\0'))
    target = next(exe.search(p32(offset)))
    size = 181
    code = exe.read(target - size, size)
    code = disasm(code)

    #  print(hex(target))
    #  print(code)

    dataaddr = int(re.findall('mov    esi, (0x[0-9a-f]+)', code)[0], 16)
    data = exe.read(dataaddr, 0x100)

    calls = re.findall('call   (0x[0-9a-f]+)', code)
    decrypt_func = target - 118 - 63 + int(calls[1], 16)

    code = exe.read(decrypt_func+52, 6)
    code = disasm(code)
    key_off = int(re.findall('(0x[0-9a-f]+)', code)[0], 16)
    key = exe.read(key_off, 0x20)
    #  print(code, key_off, key)

    code = bytes(rc4(key, data))

    key = code[0x10:][::10][:12]
    key += code[0x84:][::6]
    res = bytes(key[:-1])
    #  print(res)
    return res

num_rounds = 20
for _ in range(num_rounds):
    line = io.readline().decode().strip()
    print(line)

    io.readuntil('Crackme: ')
    challenge_b64 = io.readline().decode().strip()
    # print(challenge_b64)
    challenge_data = b64d(challenge_b64.encode())

    with open('/tmp/x', 'wb') as f:
        f.write(challenge_data)
    exe = ELF('/tmp/x', False)
    challenge_password = solve(exe)

    io.sendlineafter(b': ', challenge_password)

    line = io.readline().decode().strip()
    print(line)
    assert 'Correct' in line

print(io.clean(1))

