use celery::prelude::*;
use flate2::read::GzDecoder;
use log::info;
use tar::Archive;
use tempfile::TempDir;

async fn _do_build_exploit(exploit: &Exploit) -> TaskResult<bool> {
    let exploit_dir = unpack_exploit(exploit).await?;

    let tempdir_path = match exploit_dir.path().to_str() {
        Some(path) => path.to_string(),
        None => {
            return Err(TaskError::UnexpectedError(format!(
                "Exploit {}, invalid temporary path for build files while building",
                exploit.exploit_id()
            )))
        }
    };

    let image_tag = &format!("{}{}:latest", DOCKER_REPO.as_str(), exploit.archive_id());

    let mut exploit_build = std::process::Command::new("docker")
        .args(["build", "-t", image_tag, &tempdir_path])
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker build: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let build_status = exploit_build.wait().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to execute Docker build: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    exploit_dir.close().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to clean up build files: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    if !build_status.success() {
        return Ok(false);
    }

    let mut exploit_push = std::process::Command::new("docker")
        .args(["push", image_tag])
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker push: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let push_status = exploit_push.wait().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to execute Docker push: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    let mut exploit_remove = std::process::Command::new("docker")
        .args(["image", "remove", image_tag])
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker remove: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let remove_status = exploit_remove.wait().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to execute Docker remove: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    if push_status.success() && remove_status.success() {
        info!("Successfully built exploit {}", exploit.exploit_id());
        Ok(true)
    } else {
        info!(
            "Exploit {}, pushed: {}, cleaned: {}",
            exploit.exploit_id(),
            push_status.success(),
            remove_status.success()
        );

        Err(TaskError::UnexpectedError(format!(
            "Exploit {}, error while pushing and cleaning up exploit.",
            exploit.exploit_id()
        )))
    }
}

async fn unpack_exploit(exploit: &Exploit) -> TaskResult<TempDir> {
    let archive_path = object_store::path::Path::from(format!("{}.tar.gz", exploit.archive_id()));
    let exploit_archive = OBJECT_STORE
        .get(&archive_path)
        .await
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, Failed to retrieve exploit object: {}",
                exploit.exploit_id(),
                err
            ))
        })?
        .bytes()
        .await
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, Failed to retrieve exploit data: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let tar = GzDecoder::new(exploit_archive.as_ref());
    let mut archive = Archive::new(tar);

    let tempdir = tempfile::Builder::new()
        .prefix(format!("{}/{}", BUILD_PATH.as_str(), exploit.exploit_id()).as_str())
        .tempdir()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to create temporary directory: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    archive.unpack(tempdir.path()).map_err(|err| {
        TaskError::ExpectedError(format!(
            "Exploit {}, Failed to unpack exploit archive: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    Ok(tempdir)
}
