use std::sync::Arc;

use backon::ConstantBuilder;
use backon::Retryable;
use celery::prelude::*;
use celery::Celery;
use celery::CeleryBuilder;
use diesel::prelude::*;
use diesel::r2d2;
use diesel::PgConnection;
use lazy_static::lazy_static;
use log::{info, warn};
use nix::sys::signal::{self, Signal};
use nix::unistd::Pid;
use std::time::Duration;
use std::time::Instant;
use tokio::task;
use uuid::Uuid;

use common::models::{Challenge, ChallengeId, Exploit, ExploitOutput, ExploitStatus};

#[derive(PartialEq)]
enum NetworkDelete {
    Force,
    NoForce,
}

// TODO (P2): Remove this cursed global variable hack once celery-rs supports passing extra data
//       https://github.com/rusty-celery/rusty-celery/issues/152
lazy_static! {
    static ref DB_POOL: r2d2::Pool<r2d2::ConnectionManager<PgConnection>> =
        common::setup_database_pool().expect("Failed to connect to database");
}
lazy_static! {
    static ref EXPLOIT_DOCKER_REPO: String =
        std::env::var("EXPLOIT_DOCKER_REPO").expect("EXPLOIT_DOCKER_REPO not set");
}
lazy_static! {
    static ref CHALLENGE_DOCKER_REPO: String =
        std::env::var("CHALLENGE_DOCKER_REPO").expect("CHALLENGE_DOCKER_REPO not set");
}
lazy_static! {
    static ref CONTAINER_RUNNER: String =
        std::env::var("CONTAINER_RUNNER").expect("CONTAINER_RUNNER not set");
}
lazy_static! {
    static ref DISK_LIMIT_AVAILABLE: bool = std::env::var("DISK_LIMIT_AVAILABLE").is_ok();
}

const SECRET_PREFIX: &str = "bd03ddaead52dd9f";
const EXPLOIT_MEMORY: &str = "2g";
const EXPLOIT_CPU: f32 = 1.0;
const EXPLOIT_DISK: &str = "10g";
const CHALLENGE_MEMORY: &str = "2g";
const CHALLENGE_CPU: f32 = 1.0;
const CHALLENGE_DISK: &str = "10g";
const EXPLOIT_MAX_SECONDS: u64 = 240;

async fn connect_celery() -> Result<Arc<Celery>, CeleryError> {
    let celery = CeleryBuilder::new(
        "celery",
        &std::env::var("AMQP_ADDR").expect("AMQP_ADDR not set"),
    )
    .default_queue("run")
    .task_retry_for_unexpected(true)
    .prefetch_count(
        num_cpus::get()
            .try_into()
            .expect("Could not convert number of CPUs to u16"),
    )
    .acks_late(true)
    .build()
    .await?;

    celery.register_task::<run_exploit>().await?;

    Ok(Arc::new(celery))
}

pub async fn configure_celery_runner() -> Result<Arc<Celery>, CeleryError> {
    let backon_settings = ConstantBuilder::default()
        .with_delay(Duration::from_secs(5))
        .with_max_times(12);
    connect_celery
        .retry(&backon_settings)
        .notify(|err: &CeleryError, dur: Duration| {
            log::info!(
                "Retrying connection to Celery in {:?}, error {:?}",
                dur,
                err
            );
        })
        .await
}

fn create_network(exploit: &Exploit, network_name: &str) -> TaskResult<()> {
    let mut exploit_network_up = std::process::Command::new(&*CONTAINER_RUNNER)
        .args([
            "network",
            "create",
            "--internal",
            "--driver",
            "bridge",
            network_name,
        ])
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker create network: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let network_up_status = exploit_network_up.wait().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to execute Docker network create: {}",
            exploit.exploit_id(),
            err
        ))
    })?;
    if !network_up_status.success() {
        return Err(TaskError::UnexpectedError(format!(
            "Exploit {}, Docker network create, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn fetch_exploit(exploit_uuid: Uuid) -> TaskResult<Exploit> {
    use common::schema::exploits::dsl::*;
    let mut conn = DB_POOL
        .get()
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;
    match exploits
        .filter(exploit_id.eq(exploit_uuid))
        .first::<Exploit>(&mut conn)
        .optional()
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?
    {
        Some(exploit) => Ok(exploit),
        None => Err(TaskError::UnexpectedError(format!(
            "Unable to find exploit with id {exploit_uuid}"
        ))),
    }
}

fn fetch_challenge(fetch_challenge_id: &ChallengeId) -> TaskResult<Challenge> {
    use common::schema::challenges::dsl::*;
    let mut conn = DB_POOL
        .get()
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;
    match challenges
        .filter(challenge_id.eq(fetch_challenge_id))
        .first::<Challenge>(&mut conn)
        .optional()
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?
    {
        Some(challenge) => Ok(challenge),
        None => Err(TaskError::UnexpectedError(format!(
            "Unable to find challenge with id {fetch_challenge_id}"
        ))),
    }
}

fn pull_exploit_image(exploit: &Exploit, exploit_image_tag: &str) -> TaskResult<()> {
    let mut exploit_pull = std::process::Command::new(&*CONTAINER_RUNNER)
        .args(["pull", exploit_image_tag])
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker pull challenge: {}",
                exploit.exploit_id(),
                err
            ))
        })?;
    let exploit_pull_status = exploit_pull.wait().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to execute Docker pull challenge: {}",
            exploit.exploit_id(),
            err
        ))
    })?;
    if !exploit_pull_status.success() {
        return Err(TaskError::UnexpectedError(format!(
            "Exploit {}, Docker pull challenge, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn delete_exploit_image(exploit: &Exploit, exploit_image_tag: &str) -> TaskResult<()> {
    let mut exploit_clean = std::process::Command::new(&*CONTAINER_RUNNER)
        .args(["rmi", exploit_image_tag])
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker rmi exploit: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let clean_status = exploit_clean.wait().map_err(|err| {
        TaskError::UnexpectedError(format!("Failed to execute Docker rmi: {err}"))
    })?;
    if !clean_status.success() {
        return Err(TaskError::UnexpectedError(format!(
            "Exploit {}, Docker rmi exploit, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn stop_challenge(exploit: &Exploit, challenge_container_name: &str) -> TaskResult<()> {
    let mut challenge_stop = std::process::Command::new(&*CONTAINER_RUNNER)
        .args(["stop", challenge_container_name])
        .spawn()
        .expect("failed to execute stop process");

    let challenge_stop_status = challenge_stop.wait().map_err(|err| {
        TaskError::UnexpectedError(format!("Failed to execute Docker stop: {err}"))
    })?;
    if !challenge_stop_status.success() {
        return Err(TaskError::UnexpectedError(format!(
            "Exploit {}, Docker stop challenge, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn delete_network(exploit: &Exploit, network_name: &str, force: &NetworkDelete) -> TaskResult<()> {
    let mut exploit_network_command = std::process::Command::new(&*CONTAINER_RUNNER);
    exploit_network_command.args(["network", "rm", network_name]);
    if *force == NetworkDelete::Force {
        exploit_network_command.arg("-f");
    }

    let mut exploit_network_down = exploit_network_command.spawn().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to spawn Docker network rm: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    let network_down_status = exploit_network_down.wait().map_err(|err| {
        TaskError::UnexpectedError(format!("Failed to execute Docker network rm: {err}"))
    })?;
    if !network_down_status.success() {
        return Err(TaskError::UnexpectedError(format!(
            "Exploit {}, Docker network rm, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

// TODO (P0): Make sure you can't guess the challenge image name ahead of release
fn run_challenge(
    exploit: &Exploit,
    challenge_image_tag: &str,
    challenge_container_name: &str,
    network_name: &str,
    uses_nsjail: &bool,
    challenge_flag: &str,
) -> TaskResult<()> {
    let mut challenge_command = std::process::Command::new(&*CONTAINER_RUNNER);
    challenge_command.args([
        "run",
        "-d",
        "--rm",
        &format!("--cpus={CHALLENGE_CPU}"),
        &format!("--memory={CHALLENGE_MEMORY}"),
        "--network",
        network_name,
        "--name",
        challenge_container_name,
        "-e",
        &format!("FLAG={challenge_flag}"),
    ]);

    if *DISK_LIMIT_AVAILABLE {
        challenge_command.args(["--storage-opt", &format!("size={CHALLENGE_DISK}")]);
    } else {
        log::warn!("Not limiting available disk space for challenge container");
    }

    if *uses_nsjail {
        challenge_command.arg("--privileged");
    }

    let challenge_run = &mut challenge_command
        .arg(challenge_image_tag)
        .spawn()
        .map_err(|err| {
            TaskError::UnexpectedError(format!(
                "Exploit {}, failed to spawn Docker run challenge: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let challenge_run_status = challenge_run.wait().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to execute Docker run challenge: {}",
            exploit.exploit_id(),
            err
        ))
    })?;
    if !challenge_run_status.success() {
        return Err(TaskError::UnexpectedError(format!(
            "Exploit {}, Docker run challenge, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn update_exploit_status_running(exploit: &Exploit) -> TaskResult<()> {
    use common::schema::exploits::dsl::*;
    let mut conn = DB_POOL
        .get()
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;
    diesel::update(&exploit)
        .set(status.eq(ExploitStatus::Running))
        .execute(&mut conn)
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;

    Ok(())
}

// TODO (P0): setup score reporting to Nautilus
fn update_exploit_status_run(
    exploit: &Exploit,
    exploit_result: Option<std::time::Duration>,
    run_stdout: &str,
    run_stderr: &str,
) -> TaskResult<()> {
    use common::schema::exploit_outputs::dsl::*;
    use common::schema::exploits::dsl::*;
    let mut conn = DB_POOL
        .get()
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;
    let update = diesel::update(&exploit);

    let update = match exploit_result {
        Some(duration) => update.set((
            status.eq(ExploitStatus::RunSolved),
            pending.eq(None::<bool>),
            run_duration.eq(Some(i32::try_from(duration.as_secs()).map_err(|err| {
                TaskError::UnexpectedError(format!(
                    "Exploit {}, duration does not fit in 32-bit integer: {}",
                    exploit.exploit_id(),
                    err
                ))
            })?)),
        )),

        None => update.set((
            status.eq(ExploitStatus::RunFailed),
            pending.eq(None::<bool>),
            run_duration.eq(None::<i32>),
        )),
    };

    update
        .execute(&mut conn)
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;

    let exploit_output = ExploitOutput::new(
        *exploit.exploit_id(),
        run_stdout.to_string(),
        run_stderr.to_string(),
    );

    diesel::insert_into(exploit_outputs)
        .values(&exploit_output)
        .execute(&mut conn)
        .map_err(|err| TaskError::UnexpectedError(err.to_string()))?;

    Ok(())
}

async fn do_run_exploit(
    exploit: &Exploit,
    challenge: &Challenge,
) -> TaskResult<(Option<std::time::Duration>, String, String)> {
    let network_name = &format!("{}-net", exploit.exploit_id());

    let exploit_image_tag = &format!(
        "{}{}:latest",
        EXPLOIT_DOCKER_REPO.as_str(),
        exploit.archive_id()
    );
    let challenge_image_tag = &format!(
        "{}{}-{}:latest",
        CHALLENGE_DOCKER_REPO.as_str(),
        SECRET_PREFIX,
        challenge.challenge_name(),
    );

    let challenge_container_name = &format!("{}-challenge", exploit.exploit_id());
    let exploit_container_name = &format!("{}-exploit", exploit.exploit_id());

    let challenge_flag = format!("LiveCTF{{{}}}", Uuid::new_v4());

    delete_network(exploit, network_name, &NetworkDelete::Force)?;
    // TODO (P2): clean up network on early error
    create_network(exploit, network_name)?;

    log::info!("Pulling exploit container {}", exploit_image_tag);
    pull_exploit_image(exploit, exploit_image_tag)?;

    log::info!("Running challenge {}", challenge_image_tag);
    run_challenge(
        exploit,
        challenge_image_tag,
        challenge_container_name,
        network_name,
        challenge.uses_nsjail(),
        &challenge_flag,
    )?;

    log::info!(
        "Running exploit container {} for challenge {}",
        exploit_container_name,
        challenge_image_tag
    );
    let exploit_start = Instant::now();
    let mut exploit_command = async_process::Command::new(&*CONTAINER_RUNNER);

    exploit_command
        .stderr(async_process::Stdio::piped())
        .stdout(async_process::Stdio::piped())
        .args([
            "run",
            "--init",
            "--rm",
            &format!("--cpus={EXPLOIT_CPU}"),
            &format!("--memory={EXPLOIT_MEMORY}"),
            "--network",
            network_name,
            "--name",
            exploit_container_name,
            "-e",
            &format!("HOST={challenge_container_name}"),
        ]);

    if *DISK_LIMIT_AVAILABLE {
        exploit_command.args(["--storage-opt", &format!("size={EXPLOIT_DISK}")]);
    } else {
        log::warn!("Not limiting available disk space for exploit container");
    }

    exploit_command.arg(exploit_image_tag);
    let mut exploit_run = exploit_command.spawn().map_err(|err| {
        TaskError::UnexpectedError(format!(
            "Exploit {}, failed to spawn exploit: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    let (exploit_success, stdout, stderr) = match tokio::time::timeout(
        Duration::from_secs(EXPLOIT_MAX_SECONDS),
        exploit_run.status(),
    )
    .await
    {
        Err(err) => {
            match exploit_run.id().try_into() {
                Err(_) => {
                    log::warn!(
                        "Exploit {}, run time limit exceeded: {}, failed to get process pid",
                        exploit.exploit_id(),
                        err
                    );
                }
                Ok(pid) => {
                    match signal::kill(Pid::from_raw(pid), Signal::SIGTERM) {
                        Ok(()) => {
                            log::info!(
                                "Exploit {}, run time limit exceeded: {}",
                                exploit.exploit_id(),
                                err
                            );
                        }
                        Err(_) => {
                            log::warn!(
                                "Exploit {}, run time limit exceeded: {}, failed to kill process",
                                exploit.exploit_id(),
                                err
                            );
                        }
                    };
                }
            };

            (None, String::from(""), String::from(""))
        }
        Ok(_) => {
            let exploit_run_ok = exploit_run.output().await.map_err(|err| {
                TaskError::UnexpectedError(format!(
                    "Exploit {}, failed to get exploit output: {}",
                    exploit.exploit_id(),
                    err
                ))
            })?;

            let stdout = String::from_utf8_lossy(&exploit_run_ok.stdout)
                .chars()
                .take(1024)
                .filter(|c| *c != '\0')
                .collect();
            let stderr = String::from_utf8_lossy(&exploit_run_ok.stderr)
                .chars()
                .take(1024)
                .filter(|c| *c != '\0')
                .collect();
            info!("Exploit stdout: {}", stdout);
            info!("Exploit stderr: {}", stderr);

            let flag_bytes = challenge_flag.as_bytes();
            let exploit_success = if exploit_run_ok
                .stdout
                .windows(flag_bytes.len())
                .any(|window| window == flag_bytes)
            {
                Some(exploit_start.elapsed())
            } else {
                None
            };

            (exploit_success, stdout, stderr)
        }
    };

    stop_challenge(exploit, challenge_container_name)?;
    if let Err(err) = delete_exploit_image(exploit, exploit_image_tag) {
        warn!("Failed to delete exploit image {exploit_image_tag}: {err}");
    }
    // TODO (P2): remove network regardless of when function exits
    if let Err(err) = delete_network(exploit, network_name, &NetworkDelete::NoForce) {
        warn!("Failed to delete exploit network {network_name}: {err}");
    };

    Ok((exploit_success, stdout, stderr))
}

#[celery::task]
pub async fn run_exploit(exploit_uuid: Uuid) -> TaskResult<()> {
    info!("Going to run exploit {}", exploit_uuid);

    let exploit_to_run = fetch_exploit(exploit_uuid)?;
    if *exploit_to_run.status() == ExploitStatus::Cancelled {
        return Ok(());
    }

    update_exploit_status_running(&exploit_to_run)?;
    let challenge = fetch_challenge(exploit_to_run.challenge_id())?;
    let (success, stdout, stderr) =
        task::block_in_place(|| do_run_exploit(&exploit_to_run, &challenge)).await?;

    // Check one final time if it was cancelled before end of run
    if *exploit_to_run.status() == ExploitStatus::Cancelled {
        return Ok(());
    }
    update_exploit_status_run(&exploit_to_run, success, &stdout, &stderr)?;

    Ok(())
}
